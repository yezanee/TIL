# 💡 **문제 분석 요약**

**문제 설명**

상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.

**오늘부터 N+1일째 되는 날 퇴사**를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.

백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.

**각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.**

N = 7인 경우에 다음과 같은 상담 일정표를 보자.

|  | 1일 | 2일 | 3일 | 4일 | 5일 | 6일 | 7일 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| Ti | 3 | 5 | 1 | 1 | 2 | 4 | 2 |
| Pi | 10 | 20 | 10 | 20 | 15 | 40 | 200 |

1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.

**상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다.** 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.

또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.

퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.

상담을 적절히 했을 때, **백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성**하시오.

</br>

**입력**

첫째 줄에 N (1 ≤ N ≤ 1,500,000)이 주어진다.

둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 50, 1 ≤ Pi ≤ 1,000)

</br>

**출력**

첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.

</br>

# 💡 **알고리즘 설계**

1. **변수 입력 처리 및 초기화**
2. **dp 테이블 채우기**
    1. 각 날짜별 최대 수익 계산
    2. 상담을 하지 않는 경우 or 상담을 하는 경우 선택 (최적해 구성)
    3. 상담을 하는 경우 → 상담이 퇴사일 전이나 당일에 끝나는 경우만 고려
3. **결과 출력**
    1. 최대 수익 출력

</br>

# 💡코드

```java
import java.util.Scanner;

public class Main
{
	public static void main(String[] args) {
	    Scanner sc = new Scanner(System.in);
		int N = sc.nextInt(); // 퇴사하기 까지 남은 시간
		int[][] calender = new int[N+1][2]; // 상담 일정표 (1-base index 사용)
		int[] dp = new int[N+1]; // 각 날짜별 최대 수익을 저장
		
		// 상담 일정 입력 받기
		for(int i = 1; i <= N; i++) {
		    calender[i][0] = sc.nextInt(); // 상담을 완료하는데 걸리는 기간
		    calender[i][1] = sc.nextInt(); // 받을 수 있는 금액
		    dp[i
		}
		
		// 각 날짜별 최대 수익 계산
		for(int i = 1; i <= N; i++) {
		    // 현재 날짜의 상담을 하지 않는 경우, 이전 날짜까지의 최대 수익을 그대로 가져옴
		    dp[i] = Math.max(dp[i], dp[i-1]);
		    
		    // 현재 날짜의 상담을 하는 경우
		    int endDate = i + calender[i][0] - 1; // 상담이 끝나는 날짜 계산
		    if(endDate <= N) { // 상담이 퇴사일 전이나 당일에 끝나는 경우
		        // 상담을 했을 때의 최대 수익과 현재까지의 최대 수익 비교 후 갱신
		        dp[endDate] = Math.max(dp[endDate], dp[i-1] + calender[i][1]);
	    	}
	    }
	    
	    // 마지막 날까지의 최대 수익 계산
	    int maxProfit = 0; // 최대 수익 저장 변수 초기화
	    for (int i = 1; i <= N; i++) { // 모든 날짜를 순회하며 최대 수익 계산
	        maxProfit = Math.max(maxProfit, dp[i]);
	    }
	    
	    System.out.println(maxProfit); // 최대 수익 출력
    }
}
```

</br>

# 💡 시간복잡도

O(N)

</br>

# 💡 막힌 이유

각 날짜별 최대 수익을 계산하는 코드를 dp로 어떻게 구현해야할지 감을 못잡았다. 심지어 gpt를 이용해서 완성된 코드를 보아도 왜 이렇게 구현하는 건지 이해가 잘 되지 않았다. 특히 이해가 안갔던 코드는

`dp[endDate] = Math.max(dp[endDate], dp[i-1] + calender[i][1]);` 

이 부분인데, 왜 이 코드가 상담을 했을 떄의 최대 수익과 현재까지의 최대 수익을 비교한 후 갱신하는 코드인지 잘 이해가 안됐다.

- 반복문을 통해 dp 배열의 모든 요소들을 다 돈다는 점을 명심하자.
    - dp[endDate]에 값이 할당된 적이 없다면 값이 0일 것이다.
    - dp[endDate]에 값이 할당된 적이 있다면 그때까지가 현재까지의 최대 수익일 것이다. 그리고, dp 배열을 기본적으로 전체적으로 한번씩 반복문을 통해 도므로, 값이 더해질 것이다.

dp 문제를 많이 접하면서 위와 같은 구성에 익숙해질 필요가 있을 것 같다 너무 어렵다 ..

</br>

# 💡 느낀점 or 기억할정보

- 자바에서 Int 배열은 따로 초기화를 해주지 않아도 `int[] dp = new int[N + 1];` 과 같이 선언할 경우 모든 요소가 다 0으로 초기화 된다
- dp 문제에서 Math.max 또는 Math.min을 통해 값을 갱신하는 경우가 잦은 것 같다. 막힌다면 이를 활용해서 코드를 짤 수 있지 않을까? 를 한번 생각해보자.
