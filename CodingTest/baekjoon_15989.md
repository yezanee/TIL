# 💡 **문제 분석 요약**

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 **방법의 수**를 구함

**< 조건 >**

1. 합을 나타낼 때는 **수를 1개 이상 사용**해야 한다.
2. 합을 이루고 있는 **수의 순서만 다른 것은 같은 것**으로 친다.
3. 입력 조건 : 첫째 줄에 **테스트 케이스의 개수 T**가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, **정수 n**이 주어진다. ( 0 < n ≤ 10,000 )
4. 출력 조건 : **각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수**를 출력한다.

# 💡 **알고리즘 설계**

1. **변수 입력 처리 및 초기화**
2. **점화식 만들기**
    1. dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
3. **dp 배열 구현**
    1. dp 배열 10001 x 4 크기로 초기화 (미리 모든 경의수를 저장하는 배열)
    2. 초기 값 설정 ( n = 1, 2, 3 )
    3. n ≥ 4인 경우에 대해 dp 배열 점화식 이용하여 채우기
4. **결과 출력**
    1. 각 테스트 케이스에 대해 방법의 수 결과 출력

# 💡코드

```java
import java.io.*;

public class Main {
    
    public static void main (String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        
        int[][] dp = new int[10001][4]; // n을 1, 2, 3으로 나타냄 (모든 경우의 수)
        
        int T = Integer.parseInt(br.readLine());
        
        // 합이 3이하인 경우는 사전에 초기값 1을 넣어준다.
        // dp[n][k]는 n을 만들 때 마지막에 k를 사용하는 경우의 수를 의미합니다.
        dp[1][1] = 1; // 1을 1로 끝내는 경우의 수: 1 (1)
        dp[2][1] = 1; // 2를 1 + 1로 끝내는 경우의 수: 1 (1 + 1)
        dp[2][2] = 1; // 2를 2로 끝내는 경우의 수: 1 (2)
        dp[3][1] = 1; // 3을 1 + 1 + 1로 끝내는 경우의 수: 1 (1 + 1 + 1)
        dp[3][2] = 1; // 3을 1 + 2로 끝내는 경우의 수: 1 (1 + 2)
        dp[3][3] = 1; // 3을 3으로 끝내는 경우의 수: 1 (3)
        
        // 주어지는 정수 n의 최댓값인 10000까지 경우의 수를 미리 저장해두고
        // 주어지는 n값에 대한 dp 를 출력한다.
        for (int j=4; j<=10000; j++) {
            dp[j][1] = dp[j-1][1];
            dp[j][2] = dp[j-2][1] + dp[j-2][2];
            dp[j][3] = dp[j-3][1] + dp[j-3][2] + dp[j-3][3];
        }
        
        for (int i=0; i<T; i++) {
            
            int n = Integer.parseInt(br.readLine());
            
            sb.append(dp[n][1] + dp[n][2] + dp[n][3] + "\n");
        }
        
        System.out.println(sb);
        
        br.close();
    }
}
```

# 💡 시간복잡도

O(N)

# 💡 막힌 이유

이 문제는 풀이 방법을 아예 이상하게 접근해서 밑의 블로그를 보며 공부하듯이 풀었다.

https://stonage.tistory.com/187

# 💡 느낀점 or 기억할정보

```java
for (int j=4; j<=10000; j++) {
		dp[j][1] = dp[j-1][1];
		dp[j][2] = dp[j-2][1] + dp[j-2][2];
		dp[j][3] = dp[j-3][1] + dp[j-3][2] + dp[j-3][3];
}
```

위와 같이 구현한 이유를 예를 들어서 이해해보자.

**n = 4일때**,

1. **dp[4][1]**
- dp[4][1] = 1 + 1 + 1 + 1 (4를 1로 끝나게 하는 1가지)
- dp[3][1] = 1 + 1 + 1 (3을 1로 끝나게 하는 1가지)
- 따라서, dp[4][1] = dp[3][1].
- ( cf. dp[5][1] 일때도 dp[4][1] 과 방법의 수는 같아진다. 해당 배열은 오름차순으로 값을 구하므로, dp[4][1]은 dp[5][1]을 구할 때 이미 구현되어 있을 것이다. )

2. **dp[4][2]**
- dp[4][2] = dp[2][1] + dp[2][2]
- dp[2][1] = 1 + 1, dp[2][2] = 1
- 따라서, dp[4][2] = (1 + 1) + 2와, 2 + 2 (4를 2로 끝나게 하는 방법의 수는 2)

3. **dp[4][3]**
- dp[4][3] = dp[1][1] + dp[1][2] + dp[1][3]
- dp [1][1] = 1, dp[1][2] = dp[1][3] = 0
- 따라서, dp[4][3] = 1 + 3 (4를 3으로 끝나게 하는 방법의 수는 1)

위의 로직을 기억하고 비슷한 문제가 나왔을 때 적용하도록 노력하자.

위의 점화식은 **`n`을 특정 숫자로 끝나게 만드는 방법의 수를 계산**하는 로직

**다음에도 해당 문제는 다시 풀어보기!**
